#nickbmyers217	il y a 3 mois:
Ok so I'mcoding along just fine so far, I'm totally on the same page as you until the dividing by z part at 2:20.
I have 2 questions about that.

First, how do you calculate the z coordinate in 2d space? It looks to me like the z coordinates are just the x components of the rotated and translated wall vectors.

Second, is there like an idiot goy's guide on the internet that explains why dividing by the z coordinate projects the 2d line in this fashion? I've been trying to wrap my head around the math, but linear algebra has never been my strong suit.

Thanks for any tips you intelligent scholars can give.


#Bisqwit			il y a 3 mois:
Width coordinate = X (X coordinate in 2D map, called tx before rotation and tx after rotation)
Depth coordinate = Z (Y coordinate in 2D map, called ty before rotation and tz after rotation)
Height coordinate = Y (arbitrarily chosen and hardcoded in the source, 50 for upper part of wall and -50 for lower part of wall).

---------------------------------------------------------------------------------------------------------------------------------

#MicroSpam	il y a 3 mois:
How did you get texture mapping to work in this engine? Did you use matrix transformations to get textures to line up with their walls, or did you somehow get OpenGL to draw textured polygons over the walls, or is it something else entirely?

# Bisqwit	il y a 3 mois:
I did not use OpenGL in this project at all.  I used linear interpolation of texture coordinates for the walls. I.e. at top is 0 and bottom is (textureheight-1). The x coordinate is more complex ((u0*((x2-x)*tz2) + u1*((x-x1)*tz1)) / ((x2-x)*tz2 + (x-x1)*tz1) if you must know), and the floor and ceiling even more so. I do not plan to teach these algorithms as I only settled for "whatever works" in this program, but you can check out the source code. The link is in the video description, which you of course have read haven't you.

-----------------------------------------------------------------------------------------------------------------------------------

#David Robert Kochil y a 8 mois:
Why did you say Doom-Style 3D-Engine? Because the part I understood didn't have to do with the doom Rendering method "binary space partitioning, which does not support multiple floors on top of each other, But your C-Based Engine does.


#Bisqwitil y a 8 mois:
I said Doom-style, because most gamers of that era immediately recall how Doom levels work, but not how Duke Nukem 3D levels work. For the most important part, they work the same: All walls are perfectly vertical, and below the floor there's nothing, above the ceiling there's nothing: And in terms of map geometry, the map is perfectly 2D, with a set of completely flat sectors, where each sector has a set of edge vertices, bewixt which walls are drawn, and a floor height and a ceiling height.

Where they differ is the exact method how they are rendered. In Duke Nukem 3D, and in my portal rendering engine, this opens the possibility of non-euclidean geometry â€“ which can incidentally be used to simulate a type of multi-floored buildings, as long as those two floors can be absolutely never observed simultaneously.

#David Robert Kochil y a 8 mois:
 Thanks for the quick response, I liked the Video anyways, yet, there are still people who believe that doom is a 3D renderer, so I wanted to clear that up anyways.

 ---------------------------------------------------------------------------------------------------------------------------------------------
